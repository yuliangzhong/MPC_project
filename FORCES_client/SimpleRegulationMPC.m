function [ controller, stages, params, codeoptions, outputs ] = SimpleRegulationMPC(system, objective, bounds, N, solvername, userOptions, debug)
%% SimpleRegulationMPC - generates an MPC regulator for a given LTI system
%   Uses the FORCESPRO code-generation system to implement an optimal MPC
%   controller that regulates the given LTI system to the origin. The stage
%   cost penalizing control inputs and state-deviation from the origin is
%   assumed to be quadratic.
%
%   SimpleRegulationMPC generates a mathematical optimization solver for
%   the following standard MPC problem:
%       min   x_N'*P*x_N + sum_{i=0}^{N-1}( x_i'*Q*x_i + u_i'*R*u_i )
%     x_i,u_i
%       s.t. x_0 = x
%            x_{i+1} = A*x_i + B*u_i  for i = 0...N-1
%            xmin <= x_i <= xmax      for i = 1...N
%            umin <= u_i <= umax      for i = 0...N-1
%
%   The matrices Q and R define the stage cost while P is usually referred
%   to as the terminal cost matrix.
%   
%   The solver generated by SimpleRegulationMPC takes the value of x_0 as a
%   parameter and returns the optimal value for u_0, i.e. the control input
%   for the first stage, if the MPC problem is feasible. Always check the
%   exitflag provided by the solver to make sure there were no issues!
%
%   The first output parameter of SimpleRegulationMPC is a simple function
%   handle wrapper around the solver that takes the current system state x,
%   hands it over to the solver in the appropriate format, and returns the
%   solver outputs. Call help YOUR_SOLVER_NAME (or help LTI_MPC_Solver if
%   no name is specified) for details.
%
%   You can use the additional output parameters of SimpleRegulationMPC to
%   call 
%     >> generateCode(stages, params, codeoptions, outputs)
%   This can be useful if you want to change some default options that are
%   not exposed in the interface of SimpleRegulationMPC or inspect what we
%   produce for you in this function and want to learn how you can use all 
%   capabilities of FORCESPRO.
%
%   Inputs:
%     system        - Struct with the following fields:
%       system.A:
%         State-transition matrix of the LTI-system to be controlled
%       system.B:
%         Input matrix of the LTI-system to be controlled
%
%     objective     - Struct with the following fields:
%       objective.Q:
%         Positive semi-definite matrix penalizing state-deviations from the origin.
%       objective.R:
%         Positive definite matrix penalizing control inputs.
%       objective.computeTerminalCost: [OPTIONAL]
%         Boolean indicating whether the terminal cost matrix P should be
%         computed by solving the discrete-time algebraic Riccati equation.
%       objective.P: [OPTIONAL]
%         Positive semi-definite matrix penalizing the terminal state. If
%         not present (or computed), Q will be used instead.
%
%     bounds        - Struct with the following fields:
%       bounds.xmin, bounds.xmax: [OPTIONAL]
%         Vectors representing component-wise lower and upper bounds on the 
%         individual states. Components can be (minus) infinity to indicate
%         unbounded states. Can be given as a scalar to specify identical
%         bounds for all states. If not present, unboundedness is assumed.
%       bounds.umin, bounds.umax: [OPTIONAL]
%         Vectors representing component-wise lower and upper bounds on the 
%         control inputs. Components can be (minus) infinity to indicate
%         unbounded inputs. Can be given as a scalar to specify identical
%         bounds for all inputs. If not present, unboundedness is assumed.
%
%     N:
%       Scalar specifying the prediction horizon for the MPC problem.
%
%     solvername [OPTIONAL]:
%       String specifying a name for the generated solver.
%
%     userOptions [OPTIONAL]:
%       Structure specifying non-standard options to use when generating
%       the MPC solver with FORCESPRO, see help getOptions for details.
%
%   Outputs:
%     controller:
%       A function handle that takes a particular value for the system
%       state, calls the solver with it, and returns the solver outputs.
%
%     stages:
%       A structure array defining the MPC problem in FORCESPRO format.
%
%     params:
%       A structure defining the inputs (parameters) to the solver, i.e.
%       this initial system state x1, in FORCESPRO format.
%
%     codeoptions:
%       A structure specifying the options used by FORCESPRO when
%       generating the MPC solver.
%
%     outputs:
%       A structure specifying which variables values the solver should
%       return, i.e. the input u1 of the first stage.
%
% See also: generateCode, getOptions
%
% This file is part of the FORCESPRO client software for Matlab.
% (c) embotech AG, 2013-2021, Zurich, Switzerland. All rights reserved.

if nargin < 5 || isempty(solvername) || ~ischar(solvername)
    solvername = 'LTI_MPC_Solver';
end

if nargin < 6 || isempty(userOptions)
    userOptions = struct();
end

if nargin < 7
    debug = false;
end

%% extract some problem data

% get the system matrices
A = system.A;
B = system.B;
[nx, nu] = size(B);

% get the input and state bounds
if ~isempty(bounds) && isfield(bounds, 'xmin')
    xmin = bounds.xmin;
else
    xmin = -inf;
end
if ~isempty(bounds) && isfield(bounds, 'xmax')
    xmax = bounds.xmax;
else
    xmax = inf;
end
if ~isempty(bounds) && isfield(bounds, 'umin')
    umin = bounds.umin;
else
    umin = -inf;
end
if ~isempty(bounds) && isfield(bounds, 'umax')
    umax = bounds.umax;
else
    umax = inf;
end


% make sure the matrices have corresponding dimensions
assert(all(size(A) == nx), 'The dimensions of A (%i x %i) and B (%i x %i) do not match!', size(A), size(B));

% make sure the bounds have appropriate dimensions
assert(isscalar(xmin) || (isvector(xmin) && length(xmin) == nx), 'The given lower bounds (size %i by %i) do not match the statespace dimension (nx = %i)!', size(xmin), nx);
assert(isscalar(xmax) || (isvector(xmax) && length(xmax) == nx), 'The given upper bounds (size %i by %i) do not match the statespace dimension (nx = %i)!', size(xmax), nx);
assert(isscalar(umin) || (isvector(umin) && length(umin) == nu), 'The given lower bounds (size %i by %i) do not match the input dimension (nu = %i)!', size(umin), nu);
assert(isscalar(umax) || (isvector(umax) && length(umax) == nu), 'The given upper bounds (size %i by %i) do not match the input dimension (nu = %i)!', size(umax), nu);

% make sure the cost-structure has appropriate dimensions
assert(isscalar(objective) && isstruct(objective) && isfield(objective, 'Q') && isfield(objective, 'R'), ...
        'The objective has to be specified in a structure with fields Q and R (and potentially P)!');

% prepare variables to hold the cost matrices
Q = objective.Q;
R = objective.R;

% make sure the cost-matrices have the right dimensions
assert(all(size(Q) == nx) && issymmetric(Q) && all(eig(Q) >= 0), ...
        'The stage cost for the state variables has to be given as a symmetric positive-semidefinite matrix!');

assert(all(size(R) == nu) && issymmetric(R) && all(eig(R) > 0), ...
        'The stage cost for the input variables has to be given as a symmetric positive-definite matrix!');

% use appropriate terminal cost matrix
if isfield(objective, 'P') && ~isempty(objective.P)
    P = objective.P;
elseif isfield(objective, 'computeTerminalCost') && objective.computeTerminalCost
    fprintf('Computing optimal terminal cost for the given dynamics and stage-cost.\n');
    P = dare(A, B, Q, R);
else
    warning(['Using the state variable stage cost matrix for the terminal stage.' char(10) 'Provide a terminal cost matrix in objective.P or specify objective.computeTerminalCost = true if you want different behavior.']);
    P = Q;
end

assert(all(size(P) == nx) && issymmetric(P) && all(eig(P) >= 0), ...
        'The terminal cost has to be a symmetric positive-semidefinite matrix!');



% make sure bounds are vectors
if isscalar(xmin) 
    xmin = xmin*ones(nx,1);
end
if isscalar(xmax) 
    xmax = xmax*ones(nx,1);
end
if isscalar(umin) 
    umin = umin*ones(nu,1);
end
if isscalar(umax) 
    umax = umax*ones(nu,1);
end

% extract infinity bounds and fix the bounding vector and index vector
% accordingly
zmin = [umin; xmin];
zmax = [umax; xmax];
lowerBoundIdx = ~isinf([umin; xmin]);
upperBoundIdx = ~isinf([umax; xmax]);

% check for infeasible bounds
assert(all(xmax - xmin > 0), 'The given state bounds are infeasible, please make sure that xmax > xmin!');
[~,degenerateIdx] = find(xmax == xmin, 1);
if ~isempty(degenerateIdx)
    warning('The state bounds are degenerate (xmin == xmax for state %i), this can lead to problems when solving the MPC problem!', degenerateIdx);
end

assert(all(umax - umin > 0), 'The given input bounds are infeasible, please make sure that umax > umin!');
[~,degenerateIdx] = find(umax == umin, 1);
if ~isempty(degenerateIdx)
    warning('The input bounds are degenerate (umin == umax for input %i), this can lead to problems when solving the MPC problem!', degenerateIdx);
end

% make sure N is given properly
assert(N >= 1 && isscalar(N) && rem(N,1) == 0, 'The prediction horizon N must be an integer scalar greater than or equal to 1!');

%% Create FORCESPRO multistage form structure
% assume variable ordering zi = [ui; xi+1] for i=1...N-1

stages = MultistageProblem(N);
for i = 1:N
    
        % dimension
        stages(i).dims.n = nx+nu; % number of stage variables
        stages(i).dims.r = nx;    % number of equality constraints        
        stages(i).dims.l = sum(lowerBoundIdx); % number of lower bounds
        stages(i).dims.u = sum(upperBoundIdx); % number of upper bounds
        
        % cost
        if i<N
            stages(i).cost.H = blkdiag(R,Q);
        else
            stages(i).cost.H = blkdiag(R,P);
        end
        stages(i).cost.f = zeros(nx+nu, 1);
        
        % lower bounds
        stages(i).ineq.b.lbidx = find(lowerBoundIdx); % lower bound acts on these indices
        stages(i).ineq.b.lb = zmin(lowerBoundIdx); % lower bound for this stage variable
        
        % upper bounds
        stages(i).ineq.b.ubidx = find(upperBoundIdx); % upper bound acts on these indices
        stages(i).ineq.b.ub = zmax(upperBoundIdx); % upper bound for this stage variable
        
        % equality constraints
        if( i < N )
            stages(i).eq.C = [zeros(nx,nu), A];
        end
        if( i>1 )
            stages(i).eq.c = zeros(nx,1);
        end
        stages(i).eq.D = [B, -eye(nx)];
        
end
params(1) = newParam('minusA_times_x0',1,'eq.c'); % RHS of first eq. constr. is a parameter: z1=-A*x0
    
 

%% define outputs of the solver
outputs(1) = newOutput('u0',1,1:nu);

%% solver settings
codeoptions = getOptions(solvername);
codeoptions.maxit = 50;

% update from user-provided structure
userFields = fieldnames(userOptions);
for i = 1:length(userFields)
    codeoptions.(userFields{i}) = userOptions.(userFields{i}); 
end

if ~debug
    %% generate code
    generateCode(stages,params,codeoptions,outputs);

    %% construct function handle to call controller

    controller = @(x0)(feval(solvername, struct('minusA_times_x0', -A*x0)));

    fprintf(['\n\n  FORCESPRO implemented a fast optimization algorithm to solve your MPC problem for you.\n'...
             '  A function handle to the controller is returned by this function (%s).\n'...
             '  To compute the optimal control input, simply call the controller with the current system state x0:\n'...
             '    >> controller = %s(...);\n'...
             '    >> [output, exitflag, info] = controller(x0);\n'...
             '\n' ...
             '  You can access the optimal control input for the first stage in output.u0.\n' ...
             '  Always check the exitflag before using output.u0! It will be 1 if the optimal control input could be calculated.\n' ...
             '\n' ...
             '  To get information about the underlying solver, type the following:\n' ...
             '    >> help %s\n' ...
             '\n  Have fun solving your MPC problems (fast)!\n'
             ], mfilename, mfilename, solvername);
else
    controller = [];
    warning('In debug mode, only returning the structures for FORCESPRO to the user!');
end

end

